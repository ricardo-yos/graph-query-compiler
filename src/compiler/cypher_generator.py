"""
Cypher Query Generator
======================

This module implements a semantic compiler that translates a structured
intermediate representation (IR) into executable Cypher queries for Neo4j.

The compiler follows a deterministic, multi-stage compilation pipeline:

    Natural Language
        → Semantic Parsing
        → Intermediate Representation (IR)
        → Cypher Compilation
        → Executable Graph Query

Compilation Pipeline:
---------------------
    IR → MATCH → WHERE → RETURN → ORDER BY → LIMIT

Each stage is implemented as an independent transformation step, allowing
fine-grained control, extensibility, and debugging.

Supported Query Patterns:
-------------------------
- node : Single-node retrieval.
- path : One-hop and multi-hop graph traversal.

Supported Constraints:
----------------------
- filters
- ordering (ORDER BY)
- ranking (ORDER BY + LIMIT)
- limits

Design Principles:
------------------
- Deterministic compilation
- Modular transformation pipeline
- Clear separation of concerns
- Strong extensibility for new graph patterns

Extensibility Roadmap:
----------------------
This compiler is designed to support future extensions such as:
- Variable-length paths
- Optional matches
- Aggregations and grouping
- Subqueries and pattern composition
- Query planning and optimization

This architecture enables the construction of a full Natural Language
Graph Query Engine, bridging semantic parsing and graph execution.
"""

from typing import Dict, Any, List


class CypherGenerator:
    """
    Compiles a structured semantic schema into a Cypher query.

    This class acts as a *query compiler*, transforming a high-level
    intermediate representation (IR) into a concrete Cypher string.

    Parameters
    ----------
    ir : Dict[str, Any]
        Intermediate representation containing the schema
        generated by the semantic parser.

    Notes
    -----
    The compiler operates in multiple stages:

        1. MATCH compilation
        2. Known constraints grounding
        3. General filters
        4. RETURN projection
        5. ORDER BY
        6. LIMIT

    Each stage is implemented as a separate private method, making
    the pipeline modular and easy to extend.
    """

    def __init__(self, ir: Dict[str, Any]):
        """
        Initializes the CypherGenerator.

        Parameters
        ----------
        ir : Dict[str, Any]
            Intermediate representation of the parsed user query.
        """
        self.ir = ir
        self.schema = ir["schema"]

        # Accumulators used during compilation to progressively
        # build different parts of the Cypher query.
        self.match_clauses: List[str] = []
        self.where_clauses: List[str] = []
        self.return_clause: str = ""
        self.order_clause: str = ""
        self.limit_clause: str = ""

        # Maps node labels to Cypher variables.
        # Example:
        #   {"Neighborhood": "n", "Place": "p"}
        #
        # This allows consistent variable reuse across MATCH,
        # WHERE, RETURN, ORDER BY, etc.
        self.alias_map: Dict[str, str] = {}

    # -------------------------------------------------
    def generate(self) -> str:
        """
        Generates the full Cypher query.

        This method orchestrates the entire compilation pipeline,
        invoking each compilation stage in the correct order.

        Returns
        -------
        str
            Fully compiled Cypher query.
        """
        self._compile_match()
        self._compile_known()
        self._compile_filters()
        self._compile_return()
        self._compile_order_by()
        self._compile_limit()

        # Assemble all query fragments, skipping empty parts
        parts = [
            *self.match_clauses,
            self._where_block(),
            self.return_clause,
            self.order_clause,
            self.limit_clause,
        ]

        return "\n".join(p for p in parts if p.strip())

    # -------------------------------------------------
    def _compile_match(self):
        """
        Compiles the MATCH clause based on the query pattern.

        Supported patterns:
        - node
        - path
        """
        pattern = self.schema["query_pattern"]

        if pattern == "node":
            self._compile_node_match()

        elif pattern == "path":
            self._compile_path_match()

        else:
            raise ValueError(f"Unsupported query pattern: {pattern}")

    # -------------------------------------------------
    def _compile_node_match(self):
        """
        Compiles a single-node MATCH pattern.

        Example:
        MATCH (n:Place)

        Notes
        -----
        The node alias is generated automatically using the
        lowercase first letter of the label.
        """
        label = self.schema["return"]["label"]

        # Variable alias = first letter of label (lowercase)
        var = label[0].lower()
        self.alias_map[label] = var

        self.match_clauses.append(f"MATCH ({var}:{label})")

    # -------------------------------------------------
    def _compile_path_match(self):
        """
        Compiles one-hop and multi-hop traversal paths.

        Example (2-hop):
        MATCH (n:Neighborhood)-[:CONTAINS]->(r:Road)-[:CONTAINS]->(p:Place)

        Notes
        -----
        Each node variable is automatically assigned using
        the first lowercase letter of its label.

        This method supports:
        - One-hop paths
        - Multi-hop paths
        """
        path = self.schema.get("path", [])

        if not path:
            raise ValueError("Path pattern requested but no path found.")

        parts = []

        for hop in path:
            from_label = hop["from"]
            to_label = hop["to"]
            rel = hop["rel"]

            # Resolve or assign alias for source node
            from_var = self.alias_map.get(from_label)
            if not from_var:
                from_var = from_label[0].lower()
                self.alias_map[from_label] = from_var

            # Resolve or assign alias for destination node
            to_var = self.alias_map.get(to_label)
            if not to_var:
                to_var = to_label[0].lower()
                self.alias_map[to_label] = to_var

            parts.append(
                f"({from_var}:{from_label})-[:{rel}]->({to_var}:{to_label})"
            )

        self.match_clauses.append("MATCH " + "".join(parts))

    # -------------------------------------------------
    def _compile_known(self):
        """
        Compiles known constraints (entity grounding).

        Known constraints represent hard bindings extracted
        from the user query.

        Example:
        WHERE n.name = 'Bairro Alfa'
        """
        for k in self.schema["known"]:
            attr = k["attribute"]
            label = k["label"]
            value = k.get("value_str") or k.get("value_int")

            var = self.alias_map[label]

            self.where_clauses.append(
                self._format_condition(var, attr, "=", value)
            )

    # -------------------------------------------------
    def _compile_filters(self):
        """
        Compiles general filtering constraints.

        Filters correspond to conditional operators such as:
        >, <, >=, <=, =, CONTAINS, etc.

        Example:
        WHERE p.rating > 4 AND p.num_reviews < 10
        """
        for f in self.schema["constraints"]["filters"]:
            attr = f["attribute"]
            label = f["label"]
            op = f["operator"]
            value = f.get("value_str") or f.get("value_int")

            var = self.alias_map[label]

            self.where_clauses.append(
                self._format_condition(var, attr, op, value)
            )

    # -------------------------------------------------
    def _compile_return(self):
        """
        Compiles the RETURN clause.

        Example:
        RETURN p.name AS name

        Notes
        -----
        If no attributes are specified, the full node
        is returned instead.
        """
        ret = self.schema["return"]
        label = ret["label"]
        attrs = ret.get("attributes", [])

        var = self.alias_map[label]

        if not attrs:
            self.return_clause = f"RETURN {var}"
            return

        projections = [f"{var}.{a} AS {a}" for a in attrs]
        self.return_clause = f"RETURN {', '.join(projections)}"

    # -------------------------------------------------
    def _compile_order_by(self):
        """
        Compiles ORDER BY clause.

        Example:
        ORDER BY p.rating DESC
        """
        orders = self.schema["constraints"]["order_by"]
        if not orders:
            return

        parts = []
        for o in orders:
            attr = o["attribute"]
            label = o["label"]
            direction = o.get("direction", "ASC")

            var = self.alias_map[label]
            parts.append(f"{var}.{attr} {direction}")

        self.order_clause = "ORDER BY " + ", ".join(parts)

    # -------------------------------------------------
    def _compile_limit(self):
        """
        Compiles LIMIT clause.

        Example:
        LIMIT 10
        """
        limits = self.schema["constraints"]["limit"]
        if not limits:
            return

        value = limits[0]
        self.limit_clause = f"LIMIT {value}"

    # -------------------------------------------------
    def _where_block(self):
        """
        Joins all WHERE predicates.

        Returns
        -------
        str
            Full WHERE clause or empty string.
        """
        if not self.where_clauses:
            return ""
        return "WHERE " + " AND ".join(self.where_clauses)

    # -------------------------------------------------
    @staticmethod
    def _format_condition(var: str, attr: str, op: str, value: Any) -> str:
        """
        Formats a Cypher condition.

        Parameters
        ----------
        var : str
            Node variable.
        attr : str
            Node attribute.
        op : str
            Comparison operator.
        value : Any
            Constraint value.

        Returns
        -------
        str
            Cypher expression.
        """
        if isinstance(value, str):
            return f"{var}.{attr} {op} '{value}'"
        return f"{var}.{attr} {op} {value}"


# -------------------------------------------------
def compile_to_cypher(ir: Dict[str, Any]) -> str:
    """
    High-level compilation entrypoint.

    This function provides a clean API for external modules
    to generate Cypher queries without interacting directly
    with the CypherGenerator class.

    Parameters
    ----------
    ir : Dict[str, Any]
        Intermediate representation.

    Returns
    -------
    str
        Cypher query.
    """
    return CypherGenerator(ir).generate()
